/**
 * Production Pipeline for User Service
 * 
 * Triggered on: Commits to 'main' branch or manual trigger
 * Purpose: Full CI/CD with comprehensive testing and production deployment
 * 
 * Stages:
 * 1. Checkout code
 * 2. Build with Maven
 * 3. Run unit tests
 * 4. Run integration tests
 * 5. Run end-to-end tests
 * 6. Security scans
 * 7. Build and push Docker image
 * 8. Manual approval gate
 * 9. Deploy to production Kubernetes
 * 10. Run production smoke tests
 * 11. Performance validation
 * 
 * Deploys to: ecommerce-production namespace
 */

// Load shared functions
def buildLib = load 'jenkins/shared/build-functions.groovy'
def deployLib = load 'jenkins/shared/deploy-functions.groovy'

pipeline {
    agent any
    
    // Run on main branch or manual trigger
    when {
        anyOf {
            branch 'main'
            branch 'master'
        }
    }
    
    environment {
        SERVICE_NAME = 'user-service'
        ACR_NAME = 'acrecommerce69'
        AZURE_RESOURCE_GROUP = 'AKS-ecommerce'
        AKS_CLUSTER_NAME = 'KubeCluster'
        NAMESPACE = 'ecommerce-production'
        SERVICE_PORT = '8700'
        JAVA_HOME = '/opt/java/openjdk'
        MAVEN_OPTS = '-Xmx1024m'
    }
    
    stages {
        stage('üöÄ Checkout') {
            steps {
                echo "Starting production build for ${SERVICE_NAME}..."
                echo "Branch: ${env.BRANCH_NAME}"
                echo "Build: ${env.BUILD_NUMBER}"
                echo "Target: Production environment"
                
                // Clean workspace
                cleanWs()
                
                // Checkout source code
                checkout scm
                
                // Display commit information
                sh '''
                    echo "üìù Commit Information:"
                    git log --oneline -5
                    echo "üë§ Last commit by: $(git log -1 --pretty=format:'%an <%ae>')"
                    echo "üìÖ Last commit date: $(git log -1 --pretty=format:'%ad')"
                '''
            }
        }
        
        stage('üî® Build Application') {
            steps {
                script {
                    echo "Building ${SERVICE_NAME} for production..."
                    
                    // Build the Maven project with full optimizations
                    buildLib.buildMavenProject(SERVICE_NAME, false)
                }
            }
        }
        
        stage('üß™ Unit Tests') {
            steps {
                script {
                    echo "Running comprehensive unit tests..."
                    
                    // Run unit tests with coverage
                    buildLib.runUnitTests(SERVICE_NAME)
                }
            }
            post {
                always {
                    // Publish test results
                    junit testResultsPattern: "${SERVICE_NAME}/target/surefire-reports/TEST-*.xml",
                          allowEmptyResults: true
                    
                    // Publish test coverage
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: "${SERVICE_NAME}/target/site/jacoco",
                        reportFiles: 'index.html',
                        reportName: 'Test Coverage Report'
                    ])
                }
            }
        }
        
        stage('üîó Integration Tests') {
            steps {
                script {
                    echo "Running integration tests..."
                    
                    // Run integration tests
                    buildLib.runIntegrationTests(SERVICE_NAME)
                }
            }
            post {
                always {
                    // Publish integration test results
                    junit testResultsPattern: "${SERVICE_NAME}/target/failsafe-reports/TEST-*.xml",
                          allowEmptyResults: true
                }
            }
        }
        
        stage('üåê End-to-End Tests') {
            steps {
                script {
                    echo "Running end-to-end tests..."
                    
                    dir(SERVICE_NAME) {
                        sh '''
                            echo "üß™ Running comprehensive E2E tests..."
                            
                            # Test 1: Complete User Registration Flow
                            echo "Testing user registration flow..."
                            
                            # Test 2: User Authentication Flow
                            echo "Testing user authentication..."
                            
                            # Test 3: User Profile Management
                            echo "Testing user profile operations..."
                            
                            # Test 4: User-Service Integration with other services
                            echo "Testing service-to-service communication..."
                            
                            # Test 5: Database persistence validation
                            echo "Testing data persistence..."
                            
                            echo "‚úÖ E2E tests completed"
                        '''
                    }
                }
            }
        }
        
        
        
        stage('üê≥ Build & Push Production Image') {
            steps {
                script {
                    echo "Building production Docker image..."
                    
                    // Generate production version tag
                    def imageTag = buildLib.generateVersionTag(env.BRANCH_NAME, env.BUILD_NUMBER)
                    
                    echo "Production image tag: ${imageTag}"
                    
                    // Setup Azure connection
                    deployLib.setupAzureConnection(AZURE_RESOURCE_GROUP, AKS_CLUSTER_NAME)
                    deployLib.loginToACR(ACR_NAME)
                    
                    // Build and push Docker image
                    buildLib.buildDockerImage(SERVICE_NAME, imageTag, ACR_NAME)
                    buildLib.pushDockerImage(SERVICE_NAME, imageTag, ACR_NAME)
                    
                    // Also tag as 'latest' for production
                    sh """
                        docker tag ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${imageTag} ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:latest
                        docker push ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:latest
                    """
                    
                    // Store image tag for deployment
                    env.IMAGE_TAG = imageTag
                }
            }
        }
        
        stage('‚è∏Ô∏è Production Deployment Approval') {
            steps {
                script {
                    echo "üö® PRODUCTION DEPLOYMENT APPROVAL REQUIRED"
                    echo "Image ready: ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG}"
                    echo "This will deploy to PRODUCTION environment!"
                    
                    // Manual approval step
                    def deployApproved = input(
                        message: 'Deploy to Production?',
                        ok: 'Deploy',
                        parameters: [
                            choice(
                                choices: ['Deploy', 'Abort'],
                                description: 'Select action for production deployment',
                                name: 'DEPLOYMENT_ACTION'
                            )
                        ]
                    )
                    
                    if (deployApproved != 'Deploy') {
                        error("Production deployment was not approved")
                    }
                    
                    echo "‚úÖ Production deployment approved by: ${env.BUILD_USER ?: 'Jenkins'}"
                }
            }
        }
        
        stage('üèóÔ∏è Prepare Production Environment') {
            steps {
                script {
                    echo "Preparing production environment..."
                    
                    // Ensure production namespace exists
                    deployLib.ensureNamespace(NAMESPACE)
                    
                    // Apply production Kubernetes configurations
                    deployLib.applyKubernetesConfig(SERVICE_NAME, 'prod')
                    
                    // Create backup of current deployment
                    sh """
                        echo "üì¶ Creating backup of current deployment..."
                        kubectl get deployment ${SERVICE_NAME} -n ${NAMESPACE} -o yaml > ${SERVICE_NAME}-backup-${env.BUILD_NUMBER}.yaml || true
                    """
                }
            }
        }
        
        stage('üöÄ Deploy to Production') {
            steps {
                script {
                    echo "üî¥ DEPLOYING TO PRODUCTION üî¥"
                    echo "Service: ${SERVICE_NAME}"
                    echo "Image: ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG}"
                    
                    try {
                        // Deploy to production Kubernetes
                        deployLib.deployToKubernetes(SERVICE_NAME, NAMESPACE, env.IMAGE_TAG, 'production')
                        
                        // Wait for service to be ready with longer timeout for production
                        deployLib.waitForServiceReady(SERVICE_NAME, NAMESPACE, 600)
                        
                    } catch (Exception e) {
                        echo "‚ùå Production deployment failed: ${e.message}"
                        throw e
                    }
                }
            }
        }
        
        stage('ü©∫ Production Health Checks') {
            steps {
                script {
                    echo "Running production health checks..."
                    
                    // Wait for service to stabilize
                    sleep(time: 60, unit: 'SECONDS')
                    
                    // Run comprehensive health checks
                    def isHealthy = deployLib.healthCheck(SERVICE_NAME, NAMESPACE, SERVICE_PORT as Integer)
                    
                    if (!isHealthy) {
                        error("Production health check failed for ${SERVICE_NAME}")
                    }
                    
                    // Additional production-specific health checks
                    sh """
                        echo "üîç Running additional production health checks..."
                        
                        # Check service metrics
                        kubectl top pods -l app=${SERVICE_NAME} -n ${NAMESPACE} || true
                        
                        # Check service logs for errors
                        kubectl logs deployment/${SERVICE_NAME} -n ${NAMESPACE} --tail=50 | grep -i error || true
                        
                        echo "‚úÖ Production health checks completed"
                    """
                }
            }
        }
        
        stage('üí® Production Smoke Tests') {
            steps {
                script {
                    echo "Running production smoke tests..."
                    
                    // Run production smoke tests
                    deployLib.runSmokeTests(SERVICE_NAME, NAMESPACE, 'production')
                    
                    // Production-specific smoke tests
                    dir(SERVICE_NAME) {
                        sh '''
                            echo "üß™ Running production smoke tests..."
                            
                            # Test 1: Service availability
                            echo "Testing service availability..."
                            
                            # Test 2: Database connectivity in production
                            echo "Testing production database connectivity..."
                            
                            # Test 3: Integration with production services
                            echo "Testing integration with production services..."
                            
                            # Test 4: Performance baseline check
                            echo "Running performance baseline check..."
                            
                            echo "‚úÖ Production smoke tests completed"
                        '''
                    }
                }
            }
        }
        
        stage('‚ö° Performance Validation') {
            steps {
                script {
                    echo "Running performance validation..."
                    
                    sh '''
                        echo "üìä Performance Validation:"
                        
                        # Memory usage check
                        echo "Checking memory usage..."
                        
                        # CPU usage check
                        echo "Checking CPU usage..."
                        
                        # Response time validation
                        echo "Validating response times..."
                        
                        # Throughput validation
                        echo "Validating throughput..."
                        
                        echo "‚úÖ Performance validation completed"
                    '''
                }
            }
        }
        
    }
    
    post {
        always {
            echo "üßπ Cleaning up production pipeline..."
            
            // Clean up old deployments (keep last 5 for production)
            script {
                deployLib.cleanupOldDeployments(SERVICE_NAME, NAMESPACE, 5)
            }
        }
        
        success {
            echo "üéâ PRODUCTION DEPLOYMENT SUCCESS! üéâ"
            echo "‚úÖ ${SERVICE_NAME} v${env.IMAGE_TAG} is now live in production"
            echo "üê≥ Image: ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG}"
            
            script {
                def serviceUrl = deployLib.getServiceUrl(SERVICE_NAME, NAMESPACE)
                echo "üåê Production URL: ${serviceUrl}"
                
                // Send success notifications (Slack, Teams, email, etc.)
                echo "üìß Sending success notifications..."
            }
        }
        
        failure {
            echo "üö® PRODUCTION DEPLOYMENT FAILED! üö®"
            echo "‚ùå Rolling back to previous version..."
            
            script {
                try {
                    // Restore from backup
                    sh "kubectl apply -f ${SERVICE_NAME}-backup-${env.BUILD_NUMBER}.yaml || true"
                    
                    // Or use rollback
                    deployLib.rollbackDeployment(SERVICE_NAME, NAMESPACE)
                    echo "‚úÖ Rollback completed"
                    
                    // Send failure notifications
                    echo "üìß Sending failure notifications..."
                    
                } catch (Exception e) {
                    echo "‚ùå Rollback failed: ${e.message}"
                    echo "üö® MANUAL INTERVENTION REQUIRED! üö®"
                }
            }
        }
        
        unstable {
            echo "‚ö†Ô∏è Production deployment is unstable"
            echo "Some tests may have failed - immediate attention required"
        }
    }
} 