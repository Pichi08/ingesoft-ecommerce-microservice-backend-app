/**
 * TEMPLATE: Pipeline for {SERVICE_NAME}
 * 
 * INSTRUCTIONS:
 * 1. Copy this file to: jenkins/microservices/{service-name}/Jenkinsfile-{env}
 * 2. Replace {SERVICE_NAME} with your actual service name (e.g., product-service)
 * 3. Replace {SERVICE_PORT} with your service port (e.g., 8800)
 * 4. Replace {BRANCH_CONDITION} with appropriate branch condition
 * 5. Replace {NAMESPACE} with target namespace
 * 6. Customize service-specific tests and checks
 * 7. Remove this comment block
 * 
 * Example replacements:
 * {SERVICE_NAME} → product-service
 * {SERVICE_PORT} → 8800  
 * {BRANCH_CONDITION} → branch 'develop'
 * {NAMESPACE} → ecommerce-stage
 */

pipeline {
    agent any
    
    // TODO: Replace with appropriate branch condition
    when {
        {BRANCH_CONDITION}
    }
    
    environment {
        // TODO: Update these values for your service
        SERVICE_NAME = '{SERVICE_NAME}'
        SERVICE_PORT = '{SERVICE_PORT}'
        
        // Standard environment variables (usually don't change)
        ACR_NAME = 'acrecommerce69'
        AZURE_RESOURCE_GROUP = 'AKS-ecommerce'
        AKS_CLUSTER_NAME = 'KubeCluster'
        NAMESPACE = '{NAMESPACE}'
        JAVA_HOME = '/opt/java/openjdk'
        MAVEN_OPTS = '-Xmx1024m'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "Starting build for ${SERVICE_NAME}"
                echo "Branch: ${env.BRANCH_NAME}"
                echo "Build: ${env.BUILD_NUMBER}"
                
                cleanWs()
                checkout scm
            }
        }
        
        stage('Build Application') {
            steps {
                script {
                    echo "Building ${SERVICE_NAME}"
                    // Build with Maven
                    dir(SERVICE_NAME) {
                        sh 'mvn clean compile'
                    }
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                script {
                    echo "Running unit tests for ${SERVICE_NAME}"
                    // Run unit tests
                    dir(SERVICE_NAME) {
                        sh 'mvn test'
                    }
                }
            }
            post {
                always {
                    junit testResults: "${SERVICE_NAME}/target/surefire-reports/TEST-*.xml",
                          allowEmptyResults: true
                }
            }
        }
        
        // TODO: Add integration tests for staging/production pipelines
        stage('Integration Tests') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Running integration tests for ${SERVICE_NAME}"
                    // Run integration tests
                    dir(SERVICE_NAME) {
                        sh 'mvn verify -Dspring.profiles.active=test'
                    }
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    // Generate version tag based on branch
                    def imageTag
                    if (env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'master') {
                        imageTag = "v1.0.${env.BUILD_NUMBER}"
                    } else if (env.BRANCH_NAME == 'develop') {
                        imageTag = "stage-${env.BUILD_NUMBER}"
                    } else {
                        def cleanBranch = env.BRANCH_NAME.replaceAll(/[^a-zA-Z0-9]/, '-').toLowerCase()
                        imageTag = "${cleanBranch}-${env.BUILD_NUMBER}"
                    }
                    echo "Building Docker image with tag: ${imageTag}"
                    
                    // Build Docker image
                    sh """
                        docker build -t ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${imageTag} \\
                            -f ${SERVICE_NAME}/Dockerfile .
                    """
                    
                    env.IMAGE_TAG = imageTag
                }
            }
        }
        
        // TODO: Add push step for staging/production pipelines
        stage('Push Docker Image') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    deployLib.setupAzureConnection(AZURE_RESOURCE_GROUP, AKS_CLUSTER_NAME)
                    deployLib.loginToACR(ACR_NAME)
                    buildLib.pushDockerImage(SERVICE_NAME, env.IMAGE_TAG, ACR_NAME)
                }
            }
        }
        
        // TODO: Add manual approval for production pipelines
        stage('Deployment Approval') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    def deployApproved = input(
                        message: 'Deploy to Production?',
                        ok: 'Deploy',
                        parameters: [
                            choice(
                                choices: ['Deploy', 'Abort'],
                                description: 'Select action',
                                name: 'DEPLOYMENT_ACTION'
                            )
                        ]
                    )
                    
                    if (deployApproved != 'Deploy') {
                        error("Deployment was not approved")
                    }
                }
            }
        }
        
        // TODO: Add deployment steps for staging/production pipelines
        stage('Deploy to Kubernetes') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Deploying ${SERVICE_NAME} to Kubernetes"
                    
                    deployLib.ensureNamespace(NAMESPACE)
                    deployLib.applyKubernetesConfig(SERVICE_NAME, env.BRANCH_NAME == 'main' ? 'prod' : 'stage')
                    deployLib.deployToKubernetes(SERVICE_NAME, NAMESPACE, env.IMAGE_TAG, 'kubernetes')
                    deployLib.waitForServiceReady(SERVICE_NAME, NAMESPACE, 300)
                }
            }
        }
        
        stage('Health Checks') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Running health checks"
                    sleep(time: 30, unit: 'SECONDS')
                    
                    def isHealthy = deployLib.healthCheck(SERVICE_NAME, NAMESPACE, SERVICE_PORT as Integer)
                    if (!isHealthy) {
                        error("Health check failed for ${SERVICE_NAME}")
                    }
                }
            }
        }
        
        stage('Smoke Tests') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Running smoke tests"
                    deployLib.runSmokeTests(SERVICE_NAME, NAMESPACE, 'deployment')
                    
                    // TODO: Add service-specific smoke tests here
                    dir(SERVICE_NAME) {
                        sh '''
                            echo "Running service-specific smoke tests"
                            
                            # TODO: Add your service-specific tests here
                            # Example:
                            # echo "Testing {SERVICE_NAME} endpoints"
                            # echo "Testing {SERVICE_NAME} database connectivity"
                            
                            echo "Service-specific smoke tests completed"
                        '''
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "Cleaning up"
            
            // Clean up Docker images to save space
            sh """
                docker rmi ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG ?: 'latest'} || true
                docker system prune -f || true
            """
        }
        
        success {
            echo "Pipeline completed successfully"
            echo "Service: ${SERVICE_NAME}"
            echo "Image: ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG ?: 'not-built'}"
            
            // TODO: Add success notifications here
        }
        
        failure {
            echo "Pipeline failed"
            
            // TODO: Add rollback logic for production deployments
            script {
                if (env.BRANCH_NAME in ['main', 'master'] && env.IMAGE_TAG) {
                    try {
                        echo "Rolling back production deployment"
                        deployLib.rollbackDeployment(SERVICE_NAME, NAMESPACE)
                    } catch (Exception e) {
                        echo "Rollback failed: ${e.message}"
                    }
                }
            }
            
            // TODO: Add failure notifications here
        }
        
        unstable {
            echo "Pipeline is unstable"
            // TODO: Add unstable notifications here
        }
    }
} 