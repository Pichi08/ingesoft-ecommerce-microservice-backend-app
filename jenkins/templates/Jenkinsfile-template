/**
 * TEMPLATE: Pipeline for {SERVICE_NAME}
 * 
 * INSTRUCTIONS:
 * 1. Copy this file to: jenkins/microservices/{service-name}/Jenkinsfile-{env}
 * 2. Replace {SERVICE_NAME} with your actual service name (e.g., product-service)
 * 3. Replace {SERVICE_PORT} with your service port (e.g., 8800)
 * 4. Replace {BRANCH_CONDITION} with appropriate branch condition
 * 5. Replace {NAMESPACE} with target namespace
 * 6. Customize service-specific tests and checks
 * 7. Remove this comment block
 * 
 * Example replacements:
 * {SERVICE_NAME} ‚Üí product-service
 * {SERVICE_PORT} ‚Üí 8800  
 * {BRANCH_CONDITION} ‚Üí branch 'develop'
 * {NAMESPACE} ‚Üí ecommerce-stage
 */

// Load shared functions
def buildLib = load 'jenkins/shared/build-functions.groovy'
def deployLib = load 'jenkins/shared/deploy-functions.groovy'

pipeline {
    agent any
    
    // TODO: Replace with appropriate branch condition
    when {
        {BRANCH_CONDITION}
    }
    
    environment {
        // TODO: Update these values for your service
        SERVICE_NAME = '{SERVICE_NAME}'
        SERVICE_PORT = '{SERVICE_PORT}'
        
        // Standard environment variables (usually don't change)
        ACR_NAME = 'acrecommerce69'
        AZURE_RESOURCE_GROUP = 'AKS-ecommerce'
        AKS_CLUSTER_NAME = 'KubeCluster'
        NAMESPACE = '{NAMESPACE}'
        JAVA_HOME = '/opt/java/openjdk'
        MAVEN_OPTS = '-Xmx1024m'
    }
    
    stages {
        stage('üöÄ Checkout') {
            steps {
                echo "Starting build for ${SERVICE_NAME}..."
                echo "Branch: ${env.BRANCH_NAME}"
                echo "Build: ${env.BUILD_NUMBER}"
                
                cleanWs()
                checkout scm
            }
        }
        
        stage('üî® Build Application') {
            steps {
                script {
                    echo "Building ${SERVICE_NAME}..."
                    buildLib.buildMavenProject(SERVICE_NAME, false)
                }
            }
        }
        
        stage('üß™ Unit Tests') {
            steps {
                script {
                    echo "Running unit tests for ${SERVICE_NAME}..."
                    buildLib.runUnitTests(SERVICE_NAME)
                }
            }
            post {
                always {
                    junit testResultsPattern: "${SERVICE_NAME}/target/surefire-reports/TEST-*.xml",
                          allowEmptyResults: true
                }
            }
        }
        
        // TODO: Add integration tests for staging/production pipelines
        stage('üîó Integration Tests') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Running integration tests for ${SERVICE_NAME}..."
                    buildLib.runIntegrationTests(SERVICE_NAME)
                }
            }
        }
        
        stage('üê≥ Build Docker Image') {
            steps {
                script {
                    def imageTag = buildLib.generateVersionTag(env.BRANCH_NAME, env.BUILD_NUMBER)
                    echo "Building Docker image with tag: ${imageTag}"
                    
                    buildLib.buildDockerImage(SERVICE_NAME, imageTag, ACR_NAME)
                    env.IMAGE_TAG = imageTag
                }
            }
        }
        
        // TODO: Add push step for staging/production pipelines
        stage('üì§ Push Docker Image') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    deployLib.setupAzureConnection(AZURE_RESOURCE_GROUP, AKS_CLUSTER_NAME)
                    deployLib.loginToACR(ACR_NAME)
                    buildLib.pushDockerImage(SERVICE_NAME, env.IMAGE_TAG, ACR_NAME)
                }
            }
        }
        
        // TODO: Add manual approval for production pipelines
        stage('‚è∏Ô∏è Deployment Approval') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    def deployApproved = input(
                        message: 'Deploy to Production?',
                        ok: 'Deploy',
                        parameters: [
                            choice(
                                choices: ['Deploy', 'Abort'],
                                description: 'Select action',
                                name: 'DEPLOYMENT_ACTION'
                            )
                        ]
                    )
                    
                    if (deployApproved != 'Deploy') {
                        error("Deployment was not approved")
                    }
                }
            }
        }
        
        // TODO: Add deployment steps for staging/production pipelines
        stage('üöÄ Deploy to Kubernetes') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Deploying ${SERVICE_NAME} to Kubernetes..."
                    
                    deployLib.ensureNamespace(NAMESPACE)
                    deployLib.applyKubernetesConfig(SERVICE_NAME, env.BRANCH_NAME == 'main' ? 'prod' : 'stage')
                    deployLib.deployToKubernetes(SERVICE_NAME, NAMESPACE, env.IMAGE_TAG, 'kubernetes')
                    deployLib.waitForServiceReady(SERVICE_NAME, NAMESPACE, 300)
                }
            }
        }
        
        stage('ü©∫ Health Checks') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Running health checks..."
                    sleep(time: 30, unit: 'SECONDS')
                    
                    def isHealthy = deployLib.healthCheck(SERVICE_NAME, NAMESPACE, SERVICE_PORT as Integer)
                    if (!isHealthy) {
                        error("Health check failed for ${SERVICE_NAME}")
                    }
                }
            }
        }
        
        stage('üí® Smoke Tests') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "Running smoke tests..."
                    deployLib.runSmokeTests(SERVICE_NAME, NAMESPACE, 'deployment')
                    
                    // TODO: Add service-specific smoke tests here
                    dir(SERVICE_NAME) {
                        sh '''
                            echo "üß™ Running service-specific smoke tests..."
                            
                            # TODO: Add your service-specific tests here
                            # Example:
                            # echo "Testing {SERVICE_NAME} endpoints..."
                            # echo "Testing {SERVICE_NAME} database connectivity..."
                            
                            echo "‚úÖ Service-specific smoke tests completed"
                        '''
                    }
                }
            }
        }
        
        stage('üìÅ Archive Artifacts') {
            steps {
                script {
                    echo "Archiving artifacts..."
                    buildLib.archiveArtifacts(SERVICE_NAME)
                    
                    // Create deployment info file
                    writeFile file: 'deployment-info.txt', text: """
Service: ${SERVICE_NAME}
Image: ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG ?: 'not-built'}
Branch: ${env.BRANCH_NAME}
Build: ${env.BUILD_NUMBER}
Timestamp: ${new Date()}
"""
                    archiveArtifacts artifacts: 'deployment-info.txt', fingerprint: true
                }
            }
        }
    }
    
    post {
        always {
            echo "üßπ Cleaning up..."
            
            // Clean up Docker images to save space
            sh """
                docker rmi ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG ?: 'latest'} || true
                docker system prune -f || true
            """
        }
        
        success {
            echo "‚úÖ Pipeline completed successfully!"
            echo "Service: ${SERVICE_NAME}"
            echo "Image: ${ACR_NAME}.azurecr.io/${SERVICE_NAME}:${env.IMAGE_TAG ?: 'not-built'}"
            
            // TODO: Add success notifications here
        }
        
        failure {
            echo "‚ùå Pipeline failed!"
            
            // TODO: Add rollback logic for production deployments
            script {
                if (env.BRANCH_NAME in ['main', 'master'] && env.IMAGE_TAG) {
                    try {
                        echo "Rolling back production deployment..."
                        deployLib.rollbackDeployment(SERVICE_NAME, NAMESPACE)
                    } catch (Exception e) {
                        echo "‚ùå Rollback failed: ${e.message}"
                    }
                }
            }
            
            // TODO: Add failure notifications here
        }
        
        unstable {
            echo "‚ö†Ô∏è Pipeline is unstable"
            // TODO: Add unstable notifications here
        }
    }
} 